Time to get started. I will try to write the code and this running commentary simultaneously.

A spec for a compact standard Scheme is at http://www.schemers.org/Documents/Standards/R5RS/.

As I'm writing something that's not meant to be a full-blown Scheme, I shall call it Sketch.

The primary guiding principle: code as simple as possible. Secondary principle, far less important: performance.

====================Fit The First================

----------Tutorial----------------

Scheme is a very simple language. The basic units you work with are 'values': values
can be given to a function, returned from a function, put into a variable. Types of
values include several primitive types: numbers, strings, etc. - and the all-important
composite type: the list.

Examples of values (more precisely, strings that would become these values if a Scheme
parser reads them):

3 - an integer
3.5 - a real number
#t - boolean true
#\A - a character, latin capital A
"foobar" - a string
foobar - a symbol; similar to a string, but not quite the same thing. Used to name
functions, variables, etc.

(3 "foo" 4.5) - a list containing three values; values in a list are separated by spaces
or more generally by whitespace.

(3 "foo" (4 #t) 5) - a list with a nested list inside it.

Any value can be _evaluated_, and doing that gives you another value. For primitive values
this doesn't mean anything, they "evaluate" to themselves. If you evaluate 3.5, you get 3.5.
The real importance of evaluation is in how it works on lists. When "evaluating" a list, 
the first value in it is taken to be a name of a function, all the other values - its arguments,
the function is called with these arguments, and what it returns is the result of the evaluation:

(+ 3 5.5) - this is a list of three values: a symbol +, and numbers 3 and 5.5. The symbol +
is connected, via some mechanism to be explained later, with the built-in addition function. Now
if we _evaluate_ the value (+ 3 5.5), this built-in function is called with arguments 3 and 5.5,
and returns 8.5, therefore that is the result of the evaluation.

(foo 4 (* 2 5)) is a list of three values, one of which is itself a list. When this list is
evaluated, first each of the arguments is evaluated: 4 evaluates to itself, while (* 2 5)
evaluates to 10, and then some funciton named foo, defined elsewhere, is called with arguments 4 and 10. Whatever it returns is the result of the evaluation.

A program in Scheme is a list of values. To run a program means to read these values and evaluate them in order. Some of these values invoke built-in functions which define new functions, such as 'foo'. Then later 'foo' itself may be invoked. As a result, two very different kinds of syntax in C: "2+4" and "int foo(int a) { return a+5; }" look like one kind of syntax in Scheme, a value: (+ 2 4) and (define (foo a) (+ a 5)).

Actually, I lied about the list: it isn't really a fundamental type of values. It's a fiction that makes it easier to write things down. Lists are really composed of pairs, where a pair _is_ a fundamental type: it's a value that holds two other values (of any type). Pairs can be written using the syntax ( . ):

(3 . "abc") is a value that is a pair. The first value in this pair is 3, the second "abc". Tradictionally the first value in a pair is called car, the second cdr, and these are the names of built-in functions that fetch first/second values out of a pair.

Lists are built from nested pairs: a list is a pair, in which the first value is the first element of the list, and the second value is a new pair, in which the first value is the second element of the list, and the second value is a new pair...

(3 4 "abc") is the same as

(3 . (4 . ("abc" . () ) ) )

Here () is a special object "the empty list", which finishes the nested iteration of pairs.

---------------braindump-------------------


