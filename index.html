My aim in this project is to write a small toy interpreter of Scheme, in C, and to document the way the codebase grows and all the important decisions are made. 

Initially I just wanted to write the interpreter, but then at some point I realized I'd spent a month thinking about it now and again, procrastinating rather than writing any code. I decided to blog about my progress, and that seemed to give me the motivational kick I needed. I'll be doing most of the coding simultaneously with the writing about it, structured in a series of fits. It'd be nice to finish all the important stuff in eight fits.

Here's a small FAQ.

Q: Why?
A: To scratch an itch. Because I haven't written any non-work code lately and I miss that. Because I want to see for myself which parts will be trivial and which ones tricky. I don't expect the end product to be useful to anyone.

Q: Why Scheme?
A: It's a simple, compact language, yet it has closures, lexical scoping and garbage collection. It barely has any syntax, so no need to mess around with parsing too much. I have some idea of the essense of the language, but never actually wrote in it; it'll be interesting to subject this belief of "having some idea" to a reality check.

Q: Why in C? Why an interpreter?
A: A whim to some degree. Perhaps I want to make it relatively fast while retaining the simplicity of the code. Also, it's been a while since I wrote in pure C.

Q: Is there anything else like it already?
A: There are dozens of toy Scheme interpreters, in all kinds of languages, including C. I've seen some of them, haven't studied their sources closely, and won't now before I finish this project.

Q: How much of a toy?
A: I'd like it to have real garbage collection, real tail recursion support, real lexical scoping, closures and macros. The core of the language, basically. 

